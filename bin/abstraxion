#!/usr/bin/env ruby

$LOAD_PATH.unshift(File.expand_path(File.join(File.dirname(__FILE__),".." , "lib")))
require 'abstraxion'

NODE_SIZE = 20
WINDOW_H = 450
WINDOW_W = 800
WHITE = Color::WHITE
RED = Color::RED
BLUE = Color::BLUE
GREEN = Color::GREEN
YELLOW = Color::YELLOW
CYAN = Color::CYAN

class Game < Chingu::Window
  def initialize
    $delay = 10
    super(WINDOW_W, WINDOW_H, false)
    $tower = MapAbxn::Tower.new(5, 5)
    $tower.grid.grid[0][2].set_type(:amplifier)
    $tower.grid.grid[1][1].set_type(:splitter)
    $tower.grid.grid[2][2].set_type(:splitter)
    $tower.grid.grid[1][2].set_type(:switcher)
    $tower.grid.grid[3][2].set_type(:splitter)
    $tower.grid.grid[3][3].set_type(:switcher)
    $tower.grid.set_neighbors
    $tower.grid.create_connection(0, 0, :E)
    $tower.grid.create_connection(1, 0, :E)
    $tower.grid.create_connection(2, 0, :S)
    $tower.grid.create_connection(2, 1, :S)
    $tower.grid.create_connection(2, 1, :W)
    $tower.grid.create_connection(1, 1, :S)
    $tower.grid.create_connection(1, 1, :W)
    $tower.grid.create_connection(0, 1, :N)
    $tower.grid.create_connection(2, 2, :S)
    $tower.grid.create_connection(2, 2, :E)
    $tower.grid.create_connection(3, 2, :S)
    $tower.grid.create_connection(2, 3, :S)
    $tower.grid.create_connection(2, 3, :W)
    $tower.grid.create_connection(1, 3, :W)
    $tower.grid.create_connection(0, 3, :N)
    $tower.grid.create_connection(0, 2, :N)
    $tower.grid.create_connection(1, 2, :S)
    $tower.grid.create_connection(3, 4, :W)
    $tower.grid.create_connection(3, 3, :S)
    $tower.grid.create_connection(2, 4, :W)
    $tower.grid.create_connection(1, 4, :N)
    $tower.grid.create_connection(3, 3, :E)
    $tower.grid.create_connection(4, 3, :N)
    $tower.grid.create_connection(4, 2, :N)
    $tower.grid.create_connection(4, 1, :N)
    $tower.grid.create_connection(4, 0, :W)
    $tower.grid.create_connection(3, 0, :W)

    $generator = MapAbxn::Generator.new(7, $tower)
    push_game_state(Play)
  end
end

class Master < Chingu::GameState
  def initialize
    Cursor.create(:x => $window.mouse_x, :y=>$window.mouse_y)
    super
  end

  def draw_tower
    $tower.grid.grid_iterator.each_with_index do |node, i|
      if !node.pulses.empty?
        draw_node(i % $tower.y, i / $tower.y, node.connections, CYAN)
      else
        case node.type
        when :basic
          draw_node(i % $tower.y, i / $tower.y, node.connections, WHITE)
        when :originator
          draw_node(i % $tower.y, i / $tower.y, node.connections, RED)
        when :amplifier
          draw_node(i % $tower.y, i / $tower.y, node.connections, BLUE)
        when :splitter
          draw_node(i % $tower.y, i / $tower.y, node.connections, GREEN)
        when :switcher
          draw_node(i % $tower.y, i / $tower.y, node.connections, YELLOW)
        end
      end
    end
  end

  def draw_node(x, y, connections, color)
    $window.fill_rect([x*NODE_SIZE, WINDOW_H / 2 - 0.5 * $tower.y * NODE_SIZE + y*NODE_SIZE, NODE_SIZE, NODE_SIZE], color, 0)
  end
end

class Build < Master
  def initialize
    super
    self.input = {  :escape => :exit,
                    :space => Play,
                    :left_mouse_button => :add_connection,
                    :right_mouse_button => :edit_node_type
    }
  end

  def add_connection
  end
  def edit_node_type
    m_x, m_y = $window.mouse_x, $window.mouse_y
    x = m_x/NODE_SIZE
    y = (m_y -(WINDOW_H / 2 - 0.5 * $tower.y * NODE_SIZE))/NODE_SIZE
    if (x > 0 || y > 0) && (x < $tower.x && y < $tower.y)
      $tower.grid.grid[y][x].set_type(toggle_type.call)
    end
  end

  def toggle_type
    @types ||= [:basic, :amplifier, :splitter, :switcher]
    return proc { @types.push(@types.shift)[0] }
  end

  def draw
    super
    draw_tower
  end
  def update
    $window.caption = "Edit Mode"
  end

end

class Play < Master
  def initialize
    @pulse = []
    super
    self.input = {  :escape => :exit,
                    :space => Build
    }
  end

  def draw_pulses
    if !@pulse.empty?
      shot = @pulse.pop
      Pulse.create(shot, :x => NODE_SIZE * $tower.x, :y => WINDOW_H / 2)
    end
  end

  def draw
    super
    draw_tower
    draw_pulses
  end
  def update
    super
    if $delay == 10
      $generator.update
      @pulse = $tower.update
      $delay = 0
    else
      $delay += 1
    end
    $window.caption = "FPS: #{$window.fps}"
  end

end

class Cursor < GameObject
  def initialize(options = {})
    super(options.merge(:image => Image["cursor.png"]))
  end
  def update
    @x = $window.mouse_x
    @y = $window.mouse_y
  end
end
class Pulse < GameObject
  def initialize(pulse, options = {})
    @pulse = pulse
    super(options.merge(:image=>Image["pulse.png"]))
  end
  def update
    @x += 5
  end
end

Game.new.show

